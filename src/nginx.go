package src

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// installNginxStream installs nginx via apt and enables the service. Logs stream into provided logger.
func installNginxStream(log func(string)) error {
	if log == nil {
		log = func(string) {}
	}
	// 预写入模块加载文件，避免系统已有 stream{} 时 postinst 失败
	if err := writeStreamLoaderConf(); err == nil {
		log("已写入模块加载文件 /etc/nginx/modules-enabled/50-mod-stream.conf")
	}
	log("执行: apt-get update")
	if err := runCmdPipe(func(s string) { log(s) }, "apt-get", "update"); err != nil {
		return err
	}
	// 使用 nginx-extras（包含大部分模块），更省心
	log("执行: apt-get install -y nginx-extras")
	if err := runCmdPipe(func(s string) { log(s) }, "apt-get", "install", "-y", "nginx-extras"); err != nil {
		return err
	}
	log("启动并启用 nginx 服务")
	_ = runCmdPipe(func(s string) { log(s) }, "systemctl", "enable", "nginx")
	_ = runCmdPipe(func(s string) { log(s) }, "systemctl", "start", "nginx")
	log("nginx 安装完成")
	return nil
}

// ensureNginxProxyConfigs writes both stream(443) and http(80) proxy configs and ensures nginx.conf includes stream.d.
func ensureNginxProxyConfigs(log func(string)) error {
	if log == nil {
		log = func(string) {}
	}
	// Ensure stream dynamic modules are loaded (Debian/Ubuntu package ships stream as dynamic)
	if err := ensureNginxStreamModules(log); err != nil {
		return err
	}
	// Ensure stream include in main config
	if err := ensureNginxStreamInclude(); err != nil {
		return err
	}
	// Ensure dirs
	_ = os.MkdirAll(NGINX_STREAM_DIR, 0o755)
	// Write stream conf (generic SNI passthrough)
	streamConf := strings.Join([]string{
		"# Generated by smartdns TUI: generic SNI passthrough for HTTPS",
		"map $ssl_preread_server_name $proxy_host {",
		"    default $ssl_preread_server_name;",
		"}",
		"server {",
		"    listen 443 reuseport;",
		"    proxy_pass $proxy_host:443;",
		"    resolver 1.1.1.1 8.8.8.8 valid=10s;",
		"    resolver_timeout 5s;",
		"    ssl_preread on;",
		"    proxy_ssl_server_name on;",
		"}",
		"",
	}, "\n")
	if err := writeFileIfChanged(NGINX_STREAM_CONF_FILE, streamConf, 0o644); err != nil {
		return fmt.Errorf("写入 stream 配置失败: %w", err)
	}
	// Write http conf (Host 透传)
	httpConf := strings.Join([]string{
		"# Generated by smartdns TUI: plain HTTP reverse proxy",
		"server {",
		"    listen 80 reuseport;",
		"    resolver 1.1.1.1 8.8.8.8 valid=10s;",
		"    resolver_timeout 5s;",
		"    set $upstream $host;",
		"    location / {",
		"        proxy_pass http://$upstream$request_uri;",
		"        proxy_set_header Host $host;",
		"        proxy_set_header X-Real-IP $remote_addr;",
		"        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;",
		"        proxy_http_version 1.1;",
		"        proxy_set_header Connection \"\";",
		"    }",
		"}",
		"",
	}, "\n")
	if err := writeFileIfChanged(NGINX_HTTP_CONF_FILE, httpConf, 0o644); err != nil {
		return fmt.Errorf("写入 http 配置失败: %w", err)
	}
	return nil
}

// ensureNginxStreamModules ensures nginx loads required dynamic modules for stream and ssl_preread.
// On Debian/Ubuntu, modules are under /usr/lib/nginx/modules and loaded via /etc/nginx/modules-enabled/*.conf.
func ensureNginxStreamModules(log func(string)) error {
	if log == nil {
		log = func(string) {}
	}
	// Ensure loader exists now that modules are present
	if err := writeStreamLoaderConf(); err != nil {
		return err
	}
	return nil
}

// writeStreamLoaderConf writes the modules-enabled loader file unconditionally (idempotent).
func writeStreamLoaderConf() error {
	_ = os.MkdirAll("/etc/nginx/modules-enabled", 0o755)
	loader := "/etc/nginx/modules-enabled/50-mod-stream.conf"
	content := strings.Join([]string{
		"# Auto-generated by smartdns TUI",
		"load_module modules/ngx_stream_module.so;",
		"load_module modules/ngx_stream_ssl_preread_module.so;",
		"",
	}, "\n")
	return writeFileIfChanged(loader, content, 0o644)
}

// ensureNginxStreamInclude adds a top-level stream block or ensures include directive exists.
func ensureNginxStreamInclude() error {
	data, err := os.ReadFile(NGINX_MAIN_CONF)
	if err != nil {
		return err
	}
	content := string(data)
	if !strings.Contains(content, "stream {") {
		// Append our own stream block at end
		add := "\n# SmartDNS stream include\nstream {\n    include " + NGINX_STREAM_DIR + "/*.conf;\n}\n"
		return os.WriteFile(NGINX_MAIN_CONF, []byte(content+add), 0o644)
	}
	// If stream exists but include missing, try to inject include just after first 'stream {'
	if strings.Contains(content, "include "+NGINX_STREAM_DIR+"/*.conf;") {
		return nil
	}
	lines := strings.Split(content, "\n")
	out := []string{}
	inStream := false
	depth := 0
	injected := false
	for _, l := range lines {
		tl := strings.TrimSpace(l)
		// track depth for braces
		if !inStream {
			out = append(out, l)
			if strings.HasPrefix(tl, "stream ") && strings.Contains(l, "{") || tl == "stream{" || tl == "stream {" {
				inStream = true
				depth = 1
				// inject include on next line
				out = append(out, "    include "+NGINX_STREAM_DIR+"/*.conf;")
				injected = true
			}
			continue
		}
		// in stream block
		// adjust depth by counting braces
		open := strings.Count(l, "{")
		close := strings.Count(l, "}")
		depth += open
		depth -= close
		out = append(out, l)
		if depth <= 0 {
			inStream = false
		}
	}
	if !injected {
		// fallback: append a separate include stream block at end (may duplicate, but avoids breaking)
		out = append(out, "", "# SmartDNS stream include", "stream {", "    include "+NGINX_STREAM_DIR+"/*.conf;", "}")
	}
	return os.WriteFile(NGINX_MAIN_CONF, []byte(strings.Join(out, "\n")), 0o644)
}

// nginxTestAndReload validates and reloads nginx.
func nginxTestAndReload(log func(string)) error {
	if log == nil {
		log = func(string) {}
	}
	log("校验 Nginx 配置: nginx -t")
	if err := runCmdPipe(func(s string) { log(s) }, "nginx", "-t"); err != nil {
		return err
	}
	log("重载 Nginx")
	if err := runCmdPipe(func(s string) { log(s) }, "systemctl", "reload", "nginx"); err != nil {
		// fallback to restart if reload fails (e.g., service not running yet)
		_ = runCmdPipe(func(s string) { log(s) }, "systemctl", "restart", "nginx")
	}
	return nil
}

// Helper to write file only when content changes
func writeFileIfChanged(path, content string, mode os.FileMode) error {
	if b, err := os.ReadFile(path); err == nil {
		if string(b) == content {
			return nil
		}
	} else {
		_ = os.MkdirAll(filepath.Dir(path), 0o755)
	}
	return os.WriteFile(path, []byte(content), mode)
}
